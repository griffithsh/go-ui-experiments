package main

import (
	"encoding/base64"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	rootFlag    string
	outFlag     string
	packageFlag string
)

func init() {
	flag.StringVar(&rootFlag, "root", "", "root path of the web files to compile")
	flag.StringVar(&outFlag, "output", "", "file to write compiled output to")
	flag.StringVar(&packageFlag, "package", "static", "go package name to use in the template")
}

func rowFor(filename string) (string, error) {
	b, err := ioutil.ReadFile(rootFlag + "/" + filename)
	if err != nil {
		return "", fmt.Errorf("read file %s: %s", filename, err)

	}
	return fmt.Sprintf(`"%s":[]byte("%s"),`, filename, base64.StdEncoding.EncodeToString(b)), nil
}

func files() []string {
	// TODO!
	result := []string{}

	filepath.Walk(rootFlag, func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			// fmt.Printf("discarding directory: %s\n", info.Name())
			return nil
		}
		types := map[string]*struct{}{
			".html": nil,
			".js":   nil,
			".css":  nil,
		}
		if _, ok := types[filepath.Ext(info.Name())]; !ok {
			// fmt.Printf("discarding non-web filetype: %s\n", filepath.Ext(info.Name()))
			return nil
		}
		f := strings.TrimPrefix(path, rootFlag)
		fmt.Printf("walked: %s\n", f)
		result = append(result, f)
		return nil
	})

	return result
}

func rows() (string, error) {
	r := []string{}
	for _, filename := range files() {
		x, err := rowFor(filename)
		if err != nil {
			return "", fmt.Errorf("%s", err)
		}
		r = append(r, x)
	}
	return strings.Join(r, "\n\t"), nil
}

func main() {
	flag.Parse()
	fmt.Println("web-compiler")

	t := `// Code generated by "web-compiler"; DO NOT EDIT

package %s

var staticMapping = map[string][]byte{
	%s
}
`
	r, err := rows()
	if err != nil {
		log.Fatal("get rows: ", err)
	}

	t = fmt.Sprintf(t, packageFlag, r)

	if err := ioutil.WriteFile(outFlag, []byte(t), 0644); err != nil {
		fmt.Printf("compile %s: could not write to %s: %s\n", rootFlag, outFlag, err)
	}

}
